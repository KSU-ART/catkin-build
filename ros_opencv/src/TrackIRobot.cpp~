#include <ros/ros.h>
#include <iostream>
#include <vector>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <ros_opencv/Diffmessage.h>
#include <ros_opencv/Boundary.h>
#include "opencv/cv.h"
#include "opencv2/core/core.hpp"
#include "opencv2/features2d/features2d.hpp"
#include "opencv2/nonfree/features2d.hpp"
#include "opencv2/calib3d/calib3d.hpp"
#include "opencv2/photo/photo.hpp"

using namespace  cv;
using namespace std;

namespace enc = sensor_msgs::image_encodings;

class ColorDetector
{
 ros::NodeHandle nh_;
 image_transport::ImageTransport it_;
 image_transport::Subscriber image_sub_;
 image_transport::Subscriber depth_image_sub;
 ros::Publisher result_pub;
 ros::Publisher result_pub_y;
 ros::Publisher depth_image_pub;
 ros_opencv::Diffmessage color;
 ros_opencv::Boundary boundmsg;
 cv::Point p;
 cv::Vec3f selectedColor;
 bool loadNewStock;

public:

 ColorDetector()
   : it_(nh_)
 {
   //result_pub_ = nh_.advertise<ros_opencv::Diffmessage>("diff" , 1);
   //result_pub_y= nh_.advertise<ros_opencv::Diffmessage>("diffy" , 1);
   result_pub= nh_.advertise<ros_opencv::Boundary>("boundaryinfo" , 1);
   image_sub_ = it_.subscribe("/rgb/image_raw", 1, &ColorDetector::imageCb, this);
 }

 ~ColorDetector()
 {

 }

Mat GetThresholdedImage(Mat img, _InputArray lowBound, _InputArray upBound)
{

Mat imgHSV(img.rows,img.cols, CV_8UC3, Scalar(0,0,0));

cvtColor(img, imgHSV, CV_BGR2HSV);

//imshow("hsv", imgHSV);

Mat imgThreshed(img.rows,img.cols, CV_8UC3, Scalar(0,0,0));

// Values 110,100,100 to 130,255,255 working perfect for Blue light
inRange((_InputArray)imgHSV, lowBound, upBound, imgThreshed);

imgHSV.release();

return imgThreshed;
}


 void imageCb(const sensor_msgs::ImageConstPtr& msg)
 {
   cv_bridge::CvImagePtr cv_ptr;
   try
   {
     cv_ptr = cv_bridge::toCvCopy(msg, enc::BGR8);
   }
   catch (cv_bridge::Exception& e)
   {
     ROS_ERROR("cv_bridge exception: %s", e.what());
     return;
   }
Point p=Point(-1,-1);
Vec3f selectedColor;
bool loadNewStock=false;

Mat frame=cv_ptr->image;
Vec3f defaultColor;
defaultColor.val[0]=defaultColor.val[1]=defaultColor.val[2]=0;
Mat frameSmall;
Mat threshSmallRed;
Mat threshSmallRed2;
Mat threshSmallGreen;
Mat threshSmallYellow;
Mat threshSmallWhite;

resize(frame,frameSmall,Size(640,480));


   if(!frame.data)
       cout << "error grabbing frame";


    if(p.x!=-1||p.y!=-1){
        selectedColor[0]=frameSmall.data[frameSmall.channels()*(frameSmall.cols*p.y + p.x) + 0];
        selectedColor[1]=frameSmall.data[frameSmall.channels()*(frameSmall.cols*p.y + p.x) + 1];
        selectedColor[2]=frameSmall.data[frameSmall.channels()*(frameSmall.cols*p.y + p.x) + 2];
    }
    else
    selectedColor= defaultColor;

//Mat imgGreenThresh = GetThresholdedImage(frameSmall, (_InputArray)cvScalar(42,100,0), (_InputArray)cvScalar(48,255,150));
Mat imgRedThresh = GetThresholdedImage(frameSmall, (_InputArray)cvScalar(0,200,80), (_InputArray)cvScalar(5,255,150));


resize(imgRedThresh,threshSmallRed,Size(640,480));
//resize(imgGreenThresh,threshSmallGreen,Size(640,480));

vector<Point> threshVector;
Mat finalImage = imgRedThresh;
for(int j=0;j<threshSmallRed.rows;j++)
{
for (int i=0;i<threshSmallRed.cols;i++)
{
if(threshSmallRed.at<uchar>(j,i)==255){  
threshVector.push_back(Point(j,i));
finalImage.at<uchar>(j,i)=255;
}
}
}

IplImage iplimg =finalImage;

// Calculate the moments to estimate the position of the color
CvMoments *moments = (CvMoments*)malloc(sizeof(CvMoments));
cvMoments(&iplimg, moments, 1);

// The actual moment values
double moment10 = cvGetSpatialMoment(moments, 1, 0);
double moment01 = cvGetSpatialMoment(moments, 0, 1);
double area = cvGetCentralMoment(moments, 0, 0);

int posX;
int posY;

if(threshVector.size()>50){
 posX = moment10/area;
 posY = moment01/area;
//cout<<"size:"<<threshVector.size()<<endl;	
}
else{
posX=-1;
posY=-1;
}

line(frameSmall, Point(60,0), Point(60,480), cvScalar(0,255,0),2,0);
line(frameSmall, Point(580,0), Point(580,480), cvScalar(0,255,0),2,0);
line(frameSmall, Point(0,60), Point(640,60), cvScalar(0,255,0),2,0);
line(frameSmall, Point(0,420), Point(640,420), cvScalar(0,255,0),2,0);

//cout << "Thresh pos: (" << posX << "," << posY << ")" << endl;

circle(frameSmall, Point(posX,posY), 30, cvScalar(255,0,0), 5, 8, 0);

int centerX= frameSmall.cols/2;
int centerY= frameSmall.rows/2;

int differenceX=posX-centerX;
int differenceY=posY-centerY;

//cout <<"X: "<<differenceX<<"Y: " <<differenceY<< endl;

//cvNamedWindow("ColorTrackerRGB");

imshow("ColorTrackerRGB", frameSmall);
imshow("ColorTrackerThresh", finalImage);
cv::waitKey(3);

threshSmallRed.release();
threshSmallYellow.release();
threshSmallGreen.release();
frameSmall.release();


boundmsg.turn=false;
boundmsg.onbound=true;
boundmsg.pointX=posX;
boundmsg.pointY=posY;

result_pub.publish(boundmsg);

}   
};

int main(int argc, char** argv)
{
 ros::init(argc, argv, "track_irobot");
 ColorDetector ld;
 ros::spin();
 return 0;
}
