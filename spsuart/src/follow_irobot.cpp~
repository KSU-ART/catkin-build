#include "ros/ros.h"
#include "px_comm/OpticalFlow.h"
#include <roscopter/RC.h>
#include <roscopter/VFR_HUD.h>
#include <ros_opencv/Diffmessage.h>
#include <ros_opencv/Boundary.h>

using namespace std;
ros::Publisher rc_pub;
double targetAltitude;
int throttlePWM;
int pitch;
int roll;
int yaw=0;
roscopter::RC rcValues;
ros::Subscriber subrc;

void flowCallback(const px_comm::OpticalFlow::ConstPtr& msg)
{
if(msg->ground_distance<1.9)
throttlePWM=1650;
else if(msg->ground_distance>2.1)
throttlePWM=1350;
else
throttlePWM=1500;
}

void flowHud(const roscopter::VFR_HUD::ConstPtr& msg){
if(msg->alt<1.9)
throttlePWM=1650;
else if(msg->alt>2.1)
throttlePWM=1350;
else
throttlePWM=1500;
}

void callback(const ros_opencv::Boundary::ConstPtr& msgs){
bool turn=msgs->turn;
bool onbound=msgs->onbound;
int x=msgs->pointX;
int y=msgs->pointY;

if(x>0 && x<300)
roll=rcValues.channel[0]+30;
else if(x>340)
roll=rcValues.channel[0]-30;
else
roll=rcValues.channel[0];

if(y>0 && y<220)
pitch=rcValues.channel[1]+30;
else if(y>260)
pitch=rcValues.channel[1]-30;
else
pitch=rcValues.channel[1];

}

void callbackrc(const roscopter::RC::ConstPtr& msgs){
if(msgs->channel[0]>1){
	rcValues.channel[0]=msgs->channel[0];
	rcValues.channel[1]=msgs->channel[1];
	rcValues.channel[2]=msgs->channel[2];
	rcValues.channel[3]=msgs->channel[3];
	rcValues.channel[4]=msgs->channel[4];
	rcValues.channel[5]=msgs->channel[5];
	rcValues.channel[6]=msgs->channel[6];
	rcValues.channel[7]=msgs->channel[7];
	yaw=rcValues.channel[3];
	subrc::shutdown();
}
}

int main(int argc, char **argv)
{
 
  ros::init(argc, argv, "follow_irobot");
  
  ros::NodeHandle n;
 
  ros::Subscriber subflow = n.subscribe("/px4flow/opt_flow", 1, flowCallback);
  ros::Subscriber subHud = n.subscribe("/vfr_hud", 1, flowHud);
  ros::Subscriber subbound = n.subscribe("boundaryinfo", 1, callback);
   subrc = n.subscribe("rc", 1, callbackrc);
  rc_pub = n.advertise<roscopter::RC>("send_rc", 1);

    roscopter::RC msg;
    msg.channel[0]=0;
    msg.channel[1]=0;
    msg.channel[2]=1700;
    msg.channel[3]=0;
    msg.channel[4]=0;
    msg.channel[5]=1000;
    msg.channel[6]=0;
    msg.channel[7]=0;
    rc_pub.publish(msg);
    ros::Rate r(10);
    double startTime=ros::Time::now().toSec();
    double stopTime=ros::Time::now().toSec() + ros::Duration(30).toSec();
    bool run=true; 
	while(ros::ok()){
            msg.channel[0]=roll;
	    msg.channel[1]=pitch;
            msg.channel[2]=throttlePWM;
            msg.channel[3]=yaw;
    	    msg.channel[4]=0;
    	    msg.channel[5]=0;
	    msg.channel[6]=0;
    	    msg.channel[7]=0;;
            rc_pub.publish(msg);
		ros::spinOnce();
		r.sleep();	
	}
	
    cout<<"Initiating Land"<<endl;
    msg.channel[0]=0;
    msg.channel[1]=0;
    msg.channel[2]=0;
    msg.channel[3]=0;
    msg.channel[4]=0;
    msg.channel[5]=2000;
    msg.channel[6]=0;
    msg.channel[7]=0;
    rc_pub.publish(msg);
    ros::Duration(5).sleep();

    msg.channel[0]=0;
    msg.channel[1]=0;
    msg.channel[2]=0;
    msg.channel[3]=0;
    msg.channel[4]=0;
    msg.channel[5]=0;
    msg.channel[6]=0;
    msg.channel[7]=0;
    rc_pub.publish(msg);
    cout<<"Closing"<<endl;
    r.sleep();
  return 0;
}

